# This version is for psiblast implementation



# HTML VERSION
# Mutation_analysis
# This program outputs interaction profile of wild and mutant residues
# You give a PDB and a set of mutations(single/multi, each mutation in one line)
# For every mutation(single/multi) a mutant will be generated by modeller
# Wild and mutant will be compared for the interaction profile of wild/mutant residues
# Suppose PDB=1GK9, u want to do 2 mutation
# Mutation-1: Single and Mutation-2 is a double
# You will get 3 PDB file, wild,mut1,mut2
# Comparison between wild and mut1 will output 2 line of int.profile, one for wild and another for mutant
# Comparison between wild and mut2 will output 4 line of int.profile, two for wild and two for mutant

# For every session a working directory specific to that session (set by prefix) will be created
# The wild PDB will be loaded in the R workspace
# All mutant pdb will be generated in the workdir with name mutant1.pdb, mutant2.pdb etc
# We need only 2 information, chain and resno to fetch interactions
tryCatch(
{
########################################################### SET All global directories #################################################################

script_dir="/var/www/Script_dir/";
work_dir="/var/www/workdir/"; # It has to be shorter coz procheck fails if a longer path comes, donno why.
pdb_dir="/data/ent";
hlinkpath="/out/";
output_dir="/data/out/";
consdir="/data/consurf/";
cslinkpath="/CS/";
upload_dir="/var/www/upload";
subpref1="HTML";
subpref2="TEXT";

########################################################### Load all Libraries and sources ########################################################
loadsource=function(script_dir,file)
{
  source(paste(script_dir,file,sep="",collapse=""));
}

library("bio3d");
library("igraph");
library("parallel",quietly=TRUE,verbose=FALSE);
loadsource(script_dir,"PATH.r");
loadsource(script_dir,"dssp.r");
loadsource(script_dir,"naccess.r");
loadsource(script_dir,"ionic.r");
loadsource(script_dir,"general.r");
loadsource(script_dir,"aroaro.r");
loadsource(script_dir,"aroS.r");
loadsource(script_dir,"catpi.r");
loadsource(script_dir,"disulfide.r");
loadsource(script_dir,"hbond.r");
loadsource(script_dir,"Hphob.r");
loadsource(script_dir,"intprofile.r");
loadsource(script_dir,"modeller.r");
loadsource(script_dir,"writehtml.r");

########################################################### Fetch arguments ########################################################
args=commandArgs(trailingOnly = TRUE);
optionfile=args[1]; # Arg1 is option file

########################################################### Get prefix ########################################################
options=read.table(optionfile,stringsAsFactors=FALSE) # Read the option file 
prefix=options[which(options$V1=="prefix"),2] # First row of option file is the session id to be used as prefix
print(c("Prefix entered",prefix));

########################################################### Check mode of operation ########################################################
modeofop=""; #mode of operation [bypdb, byupload]

if(options[which(options$V1=="pdbmode"),2]!="-")
{
  modeofop="bypdb";
}else{
  modeofop="byupload";
}

########################################################### Obtain filenames as per mode of operation ###################################################
filenames="";
pdbid="";

if(modeofop=="bypdb")
{
  pdbids=options[which(options$V1=="pdbmode"),2];
  pdbid=pdbids;
  filenames=tolower(unique(paste("pdb",pdbids,".ent",sep="")));
  print(filenames); #print(length(filenames));
}else{
  uploaddir=paste(upload_dir,"/",prefix,sep="",collapse="");
  filenames=list.files(uploaddir,pattern=".ent$|.pdb$"); #accept pdb and ent files only  
  pdb_dir=uploaddir;
}
print(pdb_dir);
print(modeofop);
print(filenames);
#count=70477; #filenames=list.files(pdb_dir,pattern=".ent$");

########################################################### Setting sfor which programs to run ###################################################
calc_uniqch=0;
calc_uniqch=as.numeric(options[which(options$V1=="uniq"),2]);
catpicut=as.numeric(options[which(options$V1=="catpicut"),2]);
ioncut=as.numeric(options[which(options$V1=="ioncut"),2]);
aroarolow=as.numeric(options[which(options$V1=="aroarolow"),2]);
aroarohigh=as.numeric(options[which(options$V1=="aroarohigh"),2]);
usedihed=as.numeric(options[which(options$V1=="usedihed"),2]);
aroarodihed=as.numeric(options[which(options$V1=="aroarodihed"),2]);
aroscut=as.numeric(options[which(options$V1=="aroscut"),2]);
hpcut=as.numeric(options[which(options$V1=="hpcut"),2]);
acclow=as.numeric(options[which(options$V1=="acclow"),2]);
conserv=as.numeric(options[which(options$V1=="conserv"),2]);
#print(c("acclow",acclow)); #print(c("conserv",conserv));

########################################################### Parse mutation file ###################################################
mutfile=args[2];
mut.lines=toupper(readLines(mutfile));
#cat(paste(c("Mutations entered are:",mut.lines,"\n"),sep="",collapse="\n"),file=logfile,sep="",eol="",append=TRUE);

######################## Set the working directory ###############################################
work_dir=paste(work_dir,prefix,sep="",collapse="");
createDir(work_dir);
setwd(work_dir);

####################### Create Output directory and log, status files #########################################
makedirPath=function(output_dir,prefix,subpref,suffix)
{
dirpath=paste(output_dir,prefix,sep="",collapse="");
subdirpath=paste(dirpath,"/",subpref,sep="",collapse="");
subsubdirpath=paste(subdirpath,"/Details",sep="",collapse="");
sumpath=paste(subdirpath,"/Mutation_summary.",suffix,sep="",collapse="");
sumpath.int="";
return(list(dirpath=dirpath,subdirpath=subdirpath,subsubdirpath=subsubdirpath,sumpath=sumpath,sumpath.int=sumpath.int));
}
htmldir=makedirPath(output_dir,prefix,subpref1,"html");
txtdir=makedirPath(output_dir,prefix,subpref2,"txt");

# create root directory
createDir(htmldir$dirpath); #/100
createDir(htmldir$subdirpath); # /100/HTML
createDir(htmldir$subsubdirpath); # /100/HTML/Details
createDir(txtdir$subdirpath); # /100/TXT
createDir(txtdir$subsubdirpath); # /100/TXT/Details

#Status file
readmefile=paste(txtdir$subdirpath,"/README.txt",sep="",collapse="");
statusfile=paste(htmldir$subdirpath,"/status.txt",sep="",collapse="");
logfile=paste(htmldir$subdirpath,"/log.txt",sep="",collapse="");

cat("The downloaded folder will contain a summary file (Mutation_summary.txt) and a folder named Details


In Mutation_summary.txt, the first column (No) represents the mutation number which has to be used to identify the corresponding mutant and detailed interaction file for that mutation.

For example: If the mutation number is 1, then in Details folder you will find 2 file corresponding to this mutation.

1) Mutant pdb file with suffix Mut1.pdb 
[For subsequent mutations, filenames will be Mut2.pdb, Mut3.pdb and so on]

2) Interaction details of the wild & mutant residues in a file with prefix Mutation1_details.txt 
[For subsequent details, filenames will be Mutation2_details.txt, Mutation3_details.txt and so on]",file=readmefile,sep="",eol="");


#################### Read Wild PDB file ##############
# Load the wild PDB file
# Parse the mutation file
# Create the mutants in the working directory
# Store the filename of wild and mutant in an array and name the variable to filenames. The order is importnat
# Set the pdb directory to the working directory.
# There is no harm in setting pdb_dir to work_dir coz we have already got the filename variable
# So read.pdb() will read the pdbnames in the filenames vector and load in the worksapce
# Read the wild pdb file

wildPDB="";
wild_nacc="";
wild_DSSP="";


pdbfile=paste(pdb_dir,"/",filenames[1],sep="");

if(!file.exists(pdbfile))
{
  cat("    Downloading the PDB file\n",file=logfile,sep="",eol="");
  print("checking file in PDB");
  
  pdblines="";
  tryCatch({pdblines=readLines(paste("http://www.rcsb.org/pdb/files/",pdbid,".pdb",sep="",collapse=""))},error = function(e){print("pdb cant download");
                                                                                                                             cat(paste("\n!!! INVALID PDB !!! ","\n",sep="",collapse=""),file=logfile,sep="",eol="",append=TRUE);stop();
  }, finally = print("Hello"))
  
  if(length(grep("ATOM",pdblines))>0)
  {
    print("Downloaded file from PDB");
    cat("    Downloaded PDB file\n",file=logfile,sep="",eol="");
    cat(pdblines,sep="\n",eol="\n",file=filenames[1]);
    pdbfile=filenames[1];
  }else{
    print(c("PDB file not found",pdbfile));
    cat("    Sorry, PDB FILE not be found in PDB database\n",file=logfile,sep="",eol="");
    cat(paste("\n!!! PDB FILE NOT FOUND !!! ",filenames[1],"\n",sep="",collapse=""),file=logfile,sep="",eol="",append=TRUE);
    stop();
  }
}

# After download or obtain of uploaded pdb file, if no ATOM record then?

if(length(grep("^ATOM",readLines(pdbfile)))==0)
{
  cat(paste("\n!!! NO ATOM RECORDS !!! ",filenames[1],"\n",sep="",collapse=""),file=logfile,sep="",eol="",append=TRUE);
  stop(); 
}

cat("    Reading the PDB file\n",file=logfile,sep="",eol="");
wildPDB=read.pdb(pdbfile,maxlines=100000,verbose=FALSE); # read the wild pdb file filenames[1]

#################### Check input mutations and filter any wrong mutants ##############
cat("##### PRE-PROCESSING ####\n\n",file=logfile,sep="",eol="");
cat("Checking input mutation formats..\n",file=logfile,sep="",eol="",append=TRUE);
# foldx format is of min 4 character wildres,chain,resno(1 digit min),mutres; So 4 and more is valid
# If in the form blank lines are added, then mut.lines will read those lines and element will be "" therefore such will be rejected
mut.lines=mut.lines[grep("^[0-9a-zA-Z,]*$",mut.lines,perl=TRUE)]
mut.lines=mut.lines[nchar(mut.lines)>=4]
cat("Removed any invalid characters and spaces..\n\n",file=logfile,sep="",eol="",append=TRUE);
print(mut.lines);
cat("\n\n##### GENERATING MUTATIONS ####\n\n",file=logfile,sep="",eol="",append=TRUE);
cat(paste(c("Total number of Mutations to be generated:",length(mut.lines),"\n\n"),sep="",collapse=""),file=logfile,sep="",eol="",append=TRUE);
cat(paste(c("Mutations to be processed are ",mut.lines),sep="",collapse="\n"),file=logfile,sep="",eol="\n\n",append=TRUE);
mut.lines=toupper(mut.lines); #change all to upper case
mut.linesNew=mut.lines;

#################### Use modeller to generate all valid mutations ##############
for(mutno in 1:length(mut.lines))
{
	print(mutno);
  cat(paste(c("Generating mutation ",mutno,": ",mut.lines[mutno]),sep="",collapse=""),file=logfile,sep="",eol="",append=TRUE);
	mutpref=paste(pdbid,"Mut",mutno,sep="",collapse="");
  print(mutpref);
	modstat=modeller(wildPDB,modellerpath,mutpref,mut.lines[mutno]); #modeller status either true or false
	print(modstat);
	if(modstat)
	{
	filenames=c(filenames,paste(mutpref,".pdb",sep="",collapse="")); #if success then do not delete that index of mut.linesNew vector and push the mutant filename
	}else{
	# Invalid mutations so delete that index and do not push the filenames
	mut.linesNew=mut.linesNew[-mutno];
	}
}

mut.lines=mut.linesNew;
print(mut.lines);
#cat("Generating Local Interaction Profiles for above mutations..\n\n",file=logfile,sep="",eol="",append=TRUE);
print(c("conserv",conserv));
print(c("modeofop",modeofop));

########################## If mode is byupload, perform conservation analysis ##########################

write2Html("<html>\n",htmldir$sumpath);
mutchains=unique(unlist(apply(matrix(mut.lines,ncol=1),1,function(x){substr(unlist(strsplit(x,",")),2,2)}))); #The name of chains in which mutation has to be carried out
print(c("mutchains",mutchains));
qtag="chain"; #query tag



#######################  Temporary prefixes ###################################
count=1;
dsspprefix=paste(prefix,"_dssp",count,sep="",collapse="");
naccprefix=paste(prefix,"_nacc",count,sep="",collapse="");
hbplusprefix=paste(prefix,"_hbplus",count,sep="",collapse="");
promotifprefix=paste(prefix,"_promotif",count,sep="",collapse="");
procheckprefix=paste(prefix,"_procheck",count,sep="",collapse="");
captureprefix=paste(prefix,"_capture",count,sep="",collapse="");

# Proceed only if at least one valid mutation is present
# Filenames[1] is always wild pdb, from 2 onwards mutant pdb starts

if(length(filenames)>1)
{
  #######################  Run DSSP,Naccess,and calculate all interactions for wildPDB ###################################
  mutPDB="";  
  wild_nacc=naccess(wildPDB,naccpath,prefix=naccprefix); # Runs naccess
  wild_DSSP=dssp_new(wildPDB,exepath=dssppath,prefix=dsspprefix); #Runs DSSP
  wild_status.DSSP=0;if(is.list(wild_DSSP)){wild_status.DSSP=1;}
  wild_status.nacc=0;if(is.list(wild_nacc)){wild_status.nacc=1;}
  wild_intList=calc_interaction(pdb=wildPDB,DSSP=wild_DSSP,nacc=wild_nacc,status.DSSP=wild_status.DSSP,status.nacc=wild_status.nacc,calc_ionic=1,calc_aroaro=1,calc_aros=1,calc_catpi=1,calc_hphob=1,calc_hbond=1,calc_disul=1,ioncut,aroarolow,aroarohigh,aroarodihed,usedihed,aroscut,catpicut,hpcut); # calculate interaction list
  
  ###################### After the mutation make the pdb_dir to current work_dir so that mutant pdb can be accesses ###########
  pdb_dir=work_dir; #print(pdb_dir); #print(filenames);
  
  if(conserv==1)
  {
    cat("##### Now Doing Conservation Analysis ####\n\n",file=logfile,sep="",eol="",append=TRUE);
    if(modeofop=="byupload")
    {
      chmat=uniqueChain_map(wildPDB); #obtain unique chain matrix where col1 enlists all chain where col2 the unique chain that it corresponds to
      chmat.ind=which(chmat[,1] %in% mutchains);
      mutchains.uniq=unique(chmat[chmat.ind,2]);
      
      for(mutch in mutchains.uniq)
      {
        cat(paste("\nConservation analysis for chain ",mutch,sep="",collapse=""),file=logfile,sep="",eol="",append=TRUE);
        print(c("Conservation analysis for chain ",mutch));
        mutch.ind=atom.select(wildPDB,chain=mutch,elety="CA",verbose=FALSE)$atom; #the CA indexes
        mutch.seq=paste(aa321(wildPDB$atom[mutch.ind,"resid"]),sep="",collapse=""); # The aa sequence of given chain obtained from CA tags
        
        #print(c("Mutchseq",mutch.seq));
        mutch.map=cbind(1:length(mutch.ind),paste(wildPDB$atom[mutch.ind,"chain"],wildPDB$atom[mutch.ind,"resno"],wildPDB$atom[mutch.ind,"resid"],sep="")); #To be written in mapfile col1: serial number of residue, col2:[Chain.Resno.Resid]
        seqfile=paste(qtag,mutch,".txt",sep="",collapse=""); #will be used as query fasta sequence
        seqpref=paste(qtag,mutch,"_cons",sep="",collapse=""); # The prefix [seq_chain.txt]
        cat(paste(">",qtag,mutch,"\n",mutch.seq,"\n",sep="",collapse=""),file=seqfile,sep="",eol=""); #write sequence to seq_A.txt file, will be used for blast
        
        seqcmd=paste("perl ",conspsiblast," ",seqfile," ",seqpref," ",logfile,sep="",collapse="");
        print(seqcmd);
        system(seqcmd,ignore.stdout=FALSE,ignore.stderr=FALSE);

        # Suppose seqpref is chainA_cons.Blast runs successfully, we will get chainA_cons_conserv.txt output file created by psiblast.pl program
        # This file has 5 column. Col1: seqno, Col2: sequence, Col3: probability, Col4: color grade, Col5: variability
        # We take seq from col2 of this file and store as pssmseq. The original query seq obtained from CA atom tags and used as query.txt to psiblast is stored in mutch.seq.
        # If mutch.seq and pssmseq are of same length then output is perfect, we can generate mapfile
        # Else no map file is generated but still we have the chainA_cons_conserv.txt file
        # In those case where map files avaibale, then we give this as output and CScore can be given
        # In those case due to sequence ambiguity between mutch.seq and pssmseq, no map files are generated, only chainA_cons_conserv.txt file can be given and CScore will be blank

        pssmfile=paste(seqpref,"_conserv.txt",sep="",collapse="");
      
        if(file.exists(pssmfile))
        {
          pssmmat=read.table(pssmfile,stringsAsFactors=FALSE,skip=6);  
          pssmseq=paste(pssmmat[,2],sep="",collapse=""); #sequence of pssm file in col2
          pssm.match=regexpr(pssmseq,mutch.seq);
       
          if(pssm.match==1 && nchar(pssmseq)==nchar(mutch.seq))
          {
            mapfile=paste(qtag,mutch,"_map.txt",sep="",collapse=""); #map file
            
            cat("Col1:Serian number\nCol2:Residue details as [Chain Resno Resid]\nCol3:Residue\nCol4:Weighted observed percentages of occurance of the residue (0-1). 1 means occuring all hits, highly conserved\nCol5: Value of Col4 scaled between 0-9 where 9 is fully conserved residue\nCol6: Other kind of observed residues in the position\n",file=mapfile,sep="",eol="");            
            write.table(cbind(mutch.map,pssmmat[,2:5]),file=mapfile,sep="\t",eol="\n",col.names=FALSE,row.names=FALSE,quote=FALSE,append=TRUE); #write map file
          }
        }
      }
      
      pssmfilenames= list.files(".","_conserv.txt"); # Original 5column output of psiblast.pl program
      mapfilenames= list.files(".","_map.txt"); # If no sequence ambiguity between mutch.seq and pssmseq, map files are generated
      psiblastfilenames= list.files(".","_cons.html"); # If psiblast runs succcessfully, we get html outputs
      pssmoutfilenames=list.files(".","_cons_pssm.txt"); # if psiblast tuns successfully we get pssm outputs
      
      if(length(pssmfilenames)>0)
      {
        write2Html("<h3>Conservation analysis</h3>\n1. Conservation scores:  ",htmldir$sumpath,TRUE);
        #  write2Html(paste("<a href='",hlinkpath,prefix,"/",subpref1,"/",entfilenames,"' target=\"_blank\" >",entfilenames,"</a>",sep="",collapse="&nbsp;&nbsp;"),htmldir$sumpath,TRUE);
        
        # If map files available then give map files else give Original 5column output of psiblast.pl program
        apply(matrix(mutchains,ncol=1),1,function(x){
          
          if(file.exists(paste(qtag,chmat[which(chmat[,1]==x),2],"_map.txt",sep="",collapse="")))
          {
          file.copy(from=paste(qtag,chmat[which(chmat[,1]==x),2],"_map.txt",sep="",collapse=""),to=htmldir$subdirpath);  
          write2Html(paste("<a href='",hlinkpath,prefix,"/",subpref1,"/",qtag,chmat[which(chmat[,1]==x),2],"_map.txt","' target=\"_blank\" > ",qtag,x," conservation","</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;",sep="",collapse=""),htmldir$sumpath,TRUE);  
          }else{
            file.copy(from=paste(qtag,chmat[which(chmat[,1]==x),2],"_conserv.txt",sep="",collapse=""),to=htmldir$subdirpath);  
            write2Html(paste("<a href='",hlinkpath,prefix,"/",subpref1,"/",qtag,chmat[which(chmat[,1]==x),2],"_conserv.txt","' target=\"_blank\" > ",qtag,x," conservation","</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;",sep="",collapse=""),htmldir$sumpath,TRUE);    
          }
        });
        
        write2Html("<br>2. Blast Outputs:  ",htmldir$sumpath,TRUE);
        #  write2Html(paste("<a href='",hlinkpath,prefix,"/",subpref1,"/",blastfiltfilenames,"' target=\"_blank\" >",blastfiltfilenames,"</a>",sep="",collapse="&nbsp;&nbsp;"),htmldir$sumpath,TRUE);
        
        apply(matrix(mutchains,ncol=1),1,function(x){
          file.copy(from=paste(qtag,chmat[which(chmat[,1]==x),2],"_cons.html",sep="",collapse=""),to=htmldir$subdirpath);  
          write2Html(paste("<a href='",hlinkpath,prefix,"/",subpref1,"/",qtag,chmat[which(chmat[,1]==x),2],"_cons.html","' target=\"_blank\" >",qtag,x," blast hits","</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;",sep="",collapse=""),htmldir$sumpath,TRUE);
          });
        write2Html("<br>3. PSSM Matrix: ",htmldir$sumpath,TRUE);
        #  write2Html(paste("<a href='",hlinkpath,prefix,"/",subpref1,"/",msafilenames,"' target=\"_blank\" >",msafilenames,"</a>",sep="",collapse="&nbsp;&nbsp;"),htmldir$sumpath,TRUE);

        apply(matrix(mutchains,ncol=1),1,function(x){
          file.copy(from=paste(qtag,chmat[which(chmat[,1]==x),2],"_cons_pssm.txt",sep="",collapse=""),to=htmldir$subdirpath);  
          write2Html(paste("<a href='",hlinkpath,prefix,"/",subpref1,"/",qtag,chmat[which(chmat[,1]==x),2],"_cons_pssm.txt","' target=\"_blank\" >",qtag,x," PSSM","</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;",sep="",collapse=""),htmldir$sumpath,TRUE);
        });

        write2Html("<br><br>\n",htmldir$sumpath,TRUE);
      }
      
    }else{
      
      write2Html("<h3>Consurf conservation analysis</h3>\n",htmldir$sumpath,TRUE);
      mutchains.temp=paste(pdbid,"_",mutchains,".txt",sep="");
      
      apply(matrix(mutchains.temp,ncol=1),1,function(x)
      	{
      	if(file.exists(paste(consdir,x,sep="",collapse="")))
      	{
      	write2Html(paste("<a href='",cslinkpath,x,"' target=\"_blank\" >",x,"</a>&nbsp;&nbsp;&nbsp;&nbsp;",sep="",collapse=""),htmldir$sumpath,TRUE);
      	}
      }
      );
      write2Html("<br><br>\n",htmldir$sumpath,TRUE);
    }
    cat("##### Finished conservation analysis\n\n",file=logfile,sep="",eol="",append=TRUE);
  }
  
####################### Write header to summary file #########################################
cat("Mutation Summary\n----------------------------------\nNo\tType\tChain\tRes.No\tRes.ID\tCScore\tIP\tIP_Net\tAP\tAP.Net\tAS\tAS.Net\tHB\tDisul\tCat-pi\tCat-pi_Net\tHphob\n",file=txtdir$sumpath);
print(htmldir$sumpath);
print_HTMLionic_mutation_start(htmldir$sumpath);
print("~");

cat("\n##### INTERACTION PROFILE CALCULATION ####\n",file=logfile,sep="",eol="",append=TRUE);

for(mutno in 2:length(filenames))
{
	count=mutno;
	txtdir$sumpath.int=paste(txtdir$subsubdirpath,"/Mutant",(mutno-1),"_details.txt",sep="",collapse="");
	htmldir$sumpath.int=paste(htmldir$subsubdirpath,"/Mutant",(mutno-1),"_details.html",sep="",collapse="");
	
	hlink.name=paste(hlinkpath,prefix,"/",subpref1,"/Details","/Mutant",(mutno-1),"_details.html",sep="",collapse="");
	hlink=paste("<a href=\"",hlink.name,"\" target=\"_blank\" >",mutno-1,"</a>");
	write2Html("<html><b><u>Below is the details of various non-bonded interactions of wild-type residues followed by mutant residues</u></b><br><br>",htmldir$sumpath.int,append=FALSE);
					
	flag=0;
	cat("Below is the details of various non-bonded interactions of wild-type residues followed by mutant residues\n\n",file=txtdir$sumpath.int,sep="",eol="");				
	print(system("ls"));
	print("+++");
	print(paste(pdb_dir,"/",filenames[mutno],sep=""));
	
	if(!file.exists(paste(pdb_dir,"/",filenames[mutno],sep="")))
	{
	cat(paste(c("Generating intprofile for ",mut.lines[mutno-1],": Invalid\n"),sep="",collapse=""),file=logfile,sep="",eol="",append=TRUE);
	next;
	}else{
	cat(paste(c("Generating intprofile for ",mut.lines[mutno-1]," mutation\n"),sep="",collapse=""),file=logfile,sep="",eol="",append=TRUE);
	}
	# Read the mutant pdb file
	mutPDB=read.pdb(paste(pdb_dir,"/",filenames[mutno],sep=""),maxlines=100000,verbose=FALSE); # read the wild pdb file filenames[1]
	print("---");
	
	dsspprefix=paste(prefix,"_dssp",count,sep="",collapse="");
	naccprefix=paste(prefix,"_nacc",count,sep="",collapse="");
	hbplusprefix=paste(prefix,"_hbplus",count,sep="",collapse="");
	promotifprefix=paste(prefix,"_promotif",count,sep="",collapse="");
	procheckprefix=paste(prefix,"_procheck",count,sep="",collapse="");
	captureprefix=paste(prefix,"_capture",count,sep="",collapse="");

	mut_nacc=naccess(mutPDB,naccpath,prefix=naccprefix); # Runs naccess
	mut_DSSP=dssp_new(mutPDB,exepath=dssppath,prefix=dsspprefix); #Runs DSSP
	mut_status.DSSP=0;if(is.list(mut_DSSP)){mut_status.DSSP=1;}
	mut_status.nacc=0;if(is.list(mut_nacc)){mut_status.nacc=1;}
	mut_intList=calc_interaction(pdb=mutPDB,DSSP=mut_DSSP,nacc=mut_nacc,status.DSSP=mut_status.DSSP,status.nacc=mut_status.nacc,calc_ionic=1,calc_aroaro=1,calc_aros=1,calc_catpi=1,calc_hphob=1,calc_hbond=1,calc_disul=1,ioncut,aroarolow,aroarohigh,aroarodihed,usedihed,aroscut,catpicut,hpcut); # calculate interaction list

	mutlist=unlist(strsplit(mut.lines[mutno-1],",")) # For 2nd mutant i.e. mutno=2, filenames[mutno]="mut1.txt" which corresponds to first line of mutfile so mut.line[mutno-1]
	mutlist=gsub(";","",mutlist);
	
	wild_patmat=cbind(substr(mutlist,2,2),substr(mutlist,3,nchar(mutlist)-1),substr(mutlist,1,1));
	mut_patmat=cbind(substr(mutlist,2,2),substr(mutlist,3,nchar(mutlist)-1),substr(mutlist,nchar(mutlist),nchar(mutlist)));
	
	print(c("mut_patmat",mut_patmat));
	

	
	# for a double mutant "VA18C,VA92C;" wild_patmat will be
	#[,1] [,2] [,3]
	#[1,] "A"  "18" "V" 
	#[2,] "A"  "92" "V" 
	# we use apply function and get a list of 2 index 
	# wild_intprof[[1]] is a profile list for first wildtpe residue and wild_intprof[[2]] is profile for second res

	wild_intprof=apply(wild_patmat,1,calc_intProfile,wild_intList,acclow)

	mut_intprof=apply(mut_patmat,1,calc_intProfile,mut_intList,acclow)

	#print(c("wild_intprof",wild_intprof));
	#print(c("mut_intprof",mut_intprof));
	
	write2Html(paste("<tr>\n<td rowspan=",nrow(mut_patmat)*2," >",sep="",collapse=""),htmldir$sumpath,append=TRUE);
	write2Html(hlink,htmldir$sumpath,append=TRUE);
	write2Html("</td>",htmldir$sumpath,append=TRUE);
	
	file.copy(from=filenames[mutno],to=paste(output_dir,prefix,"/",subpref1,"/Details",sep="",collapse="")); #copy the mutant to HTML/Details directory
	file.copy(from=filenames[mutno],to=paste(output_dir,prefix,"/",subpref2,"/Details",sep="",collapse="")); #copy the mutant to TEXT/Details directory
	
	mutlink.name=paste(hlinkpath,prefix,"/",subpref1,"/Details/",filenames[mutno],sep="",collapse="");
	mutlink=paste("<a href=\"",mutlink.name,"\" target=\"_blank\" >","Mutant","</a>");
	
	write2Html(paste("<td rowspan=",nrow(mut_patmat)*2," >",sep="",collapse=""),htmldir$sumpath,append=TRUE);
	write2Html(mutlink,htmldir$sumpath,append=TRUE);
	write2Html("</td>",htmldir$sumpath,append=TRUE);
	
	# Loop over eadh mutantion, if double then it will loop twice
	for(mutind in 1:length(wild_intprof))
	{
	# For each mutation, get wild and mutant interaction profile "no of type-interation/0"

	temp.wild=apply(matrix(1:11,ncol=1),1,function(x){ temp.val=wild_intprof[[mutind]][[x]]; if(is.matrix(temp.val)){return(nrow(temp.val))}else{return(0);};});
	temp.mut=apply(matrix(1:11,ncol=1),1,function(x){ temp.val=mut_intprof[[mutind]][[x]]; if(is.matrix(temp.val)){return(nrow(temp.val))}else{return(0);};} );
	print(temp.wild);
	print(temp.mut);
	
  wildcons="-";
	mutcons="-";
	wlink="-";
  
  if(conserv & modeofop=="bypdb")
  {
        consfile=paste(consdir,pdbid,"_",wild_patmat[mutind,1],".txt",sep="",collapse="");
        #print(consfile);#	print(file.exists(consfile));
      	
        if(file.exists(consfile))
        {
      	  conscmd=paste("cat ",consfile," | grep ",aa123(wild_patmat[mutind,3]),wild_patmat[mutind,2],":",wild_patmat[mutind,1],sep="",collapse="");
          consres="";
          tryCatch({consres=system(conscmd,ignore.stdout=FALSE,ignore.stderr=FALSE,intern=TRUE);},error=function(e){});
          print(consres);
          
      	  if(!is.list(attributes(consres)))
      	  {
      	    wildcons=substr(consres,32,32)
      	    wlink=wildcons;
      	  }
          
          #if(nchar(consres)>0)
          #{
            #wildcons=substr(consres,32,32);
            #wlink=wildcons;
            ##wlink.name=paste(cslinkpath,pdbid,"_",wild_patmat[mutind,1],".txt",sep="",collapse="");
            ##wlink=paste("<a href=\"",wlink.name,"\" target=\"_blank\" >",wildcons,"</a>");
          #}
          #print(wildcons);
        }
  }
  
  if(conserv & modeofop=="byupload")
  {
    consfile=paste(qtag,chmat[which(chmat[,1]==wild_patmat[mutind,1]),2],"_map.txt",sep="",collapse="");
    print("INSIDE FETCH");
    print(consfile);
    print(file.exists(consfile));
    if(file.exists(consfile))
    {
      conscmd=paste("grep ",chmat[which(chmat[,1]==wild_patmat[mutind,1]),2],wild_patmat[mutind,2],aa123(wild_patmat[mutind,3])," ",consfile," | awk '{print $5}'",sep="",collapse="");
      print(conscmd);
      consres="";
      #tryCatch({
        consres=system(conscmd,ignore.stdout=FALSE,ignore.stderr=FALSE,intern=TRUE);
      #},error=function(e){});
      print(consres);
      
      if(!is.list(attributes(consres)))
      {
        wildcons=consres;
        wlink=wildcons;
      }
      
      #if(nchar(consres)>0)
      #{
        #wildcons=consres;
        #wlink=wildcons;
        ##wlink.name=paste(hlinkpath,prefix,"/",subpref1,"/",consfile,sep="",collapse="");
        ##wlink=paste("<a href=\"",wlink.name,"\" target=\"_blank\" >",wildcons,"</a>");
      #}
    }
  }
  
  #wild pdb
	cat(c((mutno-1),"wild",wild_patmat[mutind,],wildcons,temp.wild),sep="\t",eol="\n",file=txtdir$sumpath,append=TRUE);
	write2Html.tableBodyOnlytd(matrix(c("wild",wild_patmat[mutind,],wlink,temp.wild),nrow=1),htmldir$sumpath,TRUE,"<td>");
	write2Html("\n</tr>\n",htmldir$sumpath,append=TRUE);
	
	#mutant
	cat(c((mutno-1),"mut",mut_patmat[mutind,],mutcons,temp.mut),sep="\t",eol="\n",file=txtdir$sumpath,append=TRUE);
	write2Html.tableBodyOnlytd(matrix(c("mut",mut_patmat[mutind,],mutcons,temp.mut),nrow=1),htmldir$sumpath,TRUE,"<td>");
	write2Html("\n</tr>\n",htmldir$sumpath,append=TRUE);

	print("*");
		if(sum(temp.wild)>0)
		{
		flag=1;
		cat(paste(c("\nWild (Format: Chain-Resno-Resid): ",wild_patmat[mutind,],"\n--------\n"),sep="",collapse=""),sep="",eol="",file=txtdir$sumpath.int,append=TRUE);
		write_intprofile(wild_intprof[[mutind]],txtdir$sumpath.int);
		write2Html(paste(c("\n<br><b><u>Wild (Format: Chain-Resno-Resid): ",wild_patmat[mutind,],"<br><br></b></u>"),sep="",collapse=""),htmldir$sumpath.int,append=TRUE);
		
		write_intprofile_HTML(wild_intprof[[mutind]],htmldir$sumpath.int);
		}else{
		cat(paste(c("\nWild:",wild_patmat[mutind,],"\n--------\nNo non-bonded interaction detected\n"),sep="",collapse=""),sep="",eol="",file=txtdir$sumpath.int,append=TRUE);
		write2Html(paste(c("\n<br><b><u>Wild:",wild_patmat[mutind,],"<br></b></u>No non-bonded interaction detected<br><br>"),sep="",collapse=""),htmldir$sumpath.int,append=TRUE);
		}
		
	print("**");	
		if(sum(temp.mut)>0)
		{
		flag=1;
		cat(paste(c("\nMut (Format: Chain-Resno-Resid): ",mut_patmat[mutind,],"\n--------\n"),sep="",collapse=""),sep="",eol="",file=txtdir$sumpath.int,append=TRUE);
		write_intprofile(mut_intprof[[mutind]],txtdir$sumpath.int);

		write2Html(paste(c("\n<br><b><u>Mut (Format: Chain-Resno-Resid): ",mut_patmat[mutind,],"<br></b></u>"),sep="",collapse=""),htmldir$sumpath.int,append=TRUE);
		write_intprofile_HTML(mut_intprof[[mutind]],htmldir$sumpath.int);
		}else{
		tempwr=paste(c("\nMut:",mut_patmat[mutind,],"\n--------\nNo non-bonded interaction detected\n"),sep="",collapse="");
		print(tempwr);
		cat(tempwr,sep="",eol="",file=txtdir$sumpath.int,append=TRUE);
		write2Html(paste(c("\n<br><b><u>Mut:",mut_patmat[mutind,],"<br></b></u>No non-bonded interaction detected<br><br>"),sep="",collapse=""),htmldir$sumpath.int,append=TRUE);
		}
	print("***");	
	}
	if(flag==0){unlink(txtdir$sumpath.int);}
	
	write2Html("</html>",htmldir$sumpath.int,append=TRUE);
} #end of for

} #end of if
write2Html("\n</table>\n",htmldir$sumpath,append=TRUE);
write2Html("\n</html>\n",htmldir$sumpath,append=TRUE);

# remove the working directory
setwd(htmldir$dirpath);
#unlink(work_dir, recursive = TRUE);
system(paste("zip -r ","./result.zip ", "./",subpref2,sep="",collapse=""),ignore.stderr=FALSE);
cat("100",file=statusfile,sep="",eol="");
print("THANKS");
},
error=function(e)
{
  print("--ERROR--");
  cat("-111",file=statusfile,sep="",eol="");
}

)
